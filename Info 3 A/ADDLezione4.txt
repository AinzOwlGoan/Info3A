------------------- da aggiungere du LATEX
\subsection{}
Dobbiamo suddividere varie feature e raggrupparle in Concerne, separando le varie divisioni tra concerne.
Mantendo alta la coesione interna e basso la componente loose portiamo ad una buona minimizzazione del design.

Principio di Single Responsibility Principle, ogni componente deve essere responsabile solo di una feature specisifica o funzonalità, aggregazione

Principio di Last Knowledge, un componente od oggetto non dovrebbe sapere dei dettagli interni degli altri componenti o oggetti

Non Ripetere, determinate funzionalità, dovrebbero essere implementate solo in un componente, la funzionalità non dovrebbe essere duplicata in altri componenti

Minimizzare il design upfront, fare un design di cose solo necessarie, specialmente per lo sviluppo agile

---------------- 
\subsection{}
L'analista software si aiuta anche con Design pattern, che vengono applicati in un contesto specifico per la risoluzione di problemi, possiamo differenziarli in 
Pattern architetturali, come i layer, oppure i pattern di Design che sono per esempio gli oggetti in una classe

Gli stili architetturali individuano una famiglia/classe organizzata in un certo modo per risolvere un problema, abbiamo componenti che interagiscono in un determinato modo
per scambiarsi componenti ed interazioni

Di solito si utilizzano molti più stili, un esempio sono le applicazioni con un'architettura a servizi multi-tier,
un esempio potrebbe essere l'unione di presentation layer, service layer, business layer, data layer. Si nota che non si ha mai un passaggio dal primo layer all'ultimo layer
senza passare dai layer intermedi!
Ogni layer cattura un "concerne" ai fini di una certa problematica, questo pattern si chiama anche Application-Presentation Layer

Observer Pattern: ogni classe svolge dei ruoli, l'interazione tra gli oggetti avviene non tramite chiamata di metodo, ma
attraverso oggetti che si registrano ad un certo evento chiamato SUBJECT, e quando viene scatenato un evento parte un metodo NOTIFY che sveglia tutti gli osservatori!

--------------------
\subsection{}
Tipicamente si parla di 4+1, 4 viste e una centrale che sono gli scenari [AGGIUNGERE IMMAGINE!!!]

Vista logica: descrive i requisiti funzionali, tipicametne si fornisce un modello statico fatto di astrazioni "componenti, classi, interazioni tra componenti"

Vista process view: dinamica, fa vedere aspetti che si verificano run-time, può fornire anche aspetti non funzinonali eg. performance

Vista sviluppo: fa vedere i moduli software (cod sorgente, jar, etc.)

Vista fisica/deployment: fa vedere l'allocazione delle componenti software nell'hardware

--------------- qualità non funzionali.
\subsection{}
Le proprietà possono interfrire tra di loro, magari volendo raggiungerne una dovrò sacrificarne un'altra,
un esempio è se uso tante componenti, miglioro le performance ma diminuisco la manutenibilità, oppure se introduco dati ridondanti
aumento l'accessibilità ma rendo la sicurezza più difficile da effettuare
-------------
\subsection{}
Per compensare le qualità non funzionali spesso si usano dei design pattern chiamati "tattiche", a seconda di ciò che utilizzo
riesco a migliorare anche le quantità non funzionali
------------ Elementi architetturali

Al solito vediamo le componenti come black-box che ci fanno vedere solo le interfacce,
////////////// 
\subsection{Componenti}
è un'entità architetturale che incapsula funzionalità e dati e restringe l'accesso attraverso interfacce (provided interfaces), 
le dipendenze che la componente ha rispetto ad altre componenti vengono definite come (required interfaces), le componenti sono date da application-specifics services,
le parti interne da una componente sono nascoste, e le interfacce sono importantissime perché saranno quelle che ci faranno collegare le componenti tra di loro.

Le componenti e i sottosistemi possono essere flessibilmente riusati e rimpiazzati, quindi io posso sostituire una componenete con un'altra se (X -> Y) solo se X e Y forniscono le stesse
interfacce o al più Y fornisce interfacce che sono una specializzazione di X, si introduce un meccanismo che serve per stabilire la compatibilità tra componenti.

Riassumendo una componente è divisa in specifica della componente che è una dichiarazione di come una componente è formata, e l'altra è l'implementazione della componente. 
Posso fornire una serie di obbligazioni, o anche degli invarianti che la componente dovrà rispettare 

\paragraph{Implementazione di una componente}

Insieme di design e algoritmi che servono per mostrare la componente come viene implementata

\subsection{Connettore}
Incapsula la funzionalità legata alla comunicazione, possiamo vederlo da un lato come una componente,
i connettori più semplici sono le query /eg. JDBC/ o le chiamate a metodo, attenzione però ai \textbf{protocolli}, perché il 
connettore è il mezzo mentre è il protocollo che dice cosa fare effettivamente!
I connettori a differenza delle componenti sono Application-Independent, perché a seconda del controllore posso sempre adattarlo a vari contesti

Connettori semplici:
\paragraph{}
- le chiamate di procedura (RPC, RMI)
- accesso a memoria condivisa 
Connettori complessi:
\paragraph{}
- protocolli client-server
- scambio di messaggi (SOAP)
- protocollo di accesso a database (JDBMS)
- eventi asincroni
Connettori di distribuzione:
\paragraph{}
- Data flow, per esempio pipe.
Wapper/ connettori adattatori:
Istanziazione
Connettori bio-ispirati, un esempio Gossip o ANT che si ispirano alla natura

///////////////////
\subsection{Configurazione}
Quando assembliamo le componenti tra di loro creiamo una particolare configurazione del sistema